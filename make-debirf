#!/bin/bash

# DEBIRF creation script.  You must pass a kernel .deb as the first argument.

CMD=$(basename $0)
CMD_PATH=$(dirname $0)

# source debirf.conf
source "$CMD_PATH/debirf.conf"

if [ "$1" ]; then
    DEBIRF_KERNEL_PACKAGE="$1"
fi

cd "$DEBIRF_PATH"

# maybe fix locales?
export LC_CTYPE="C"
export LANGUAGE="C"
export LANG="C"

msg() {
    echo "  debirf: $@"
}

export -f msg

setup_debirf_info() {
    export DEBIRF_INFO_TARGET="${DEBIRF_ROOT}/etc/debirf/debirf.info"
    mkdir -p $(dirname "$DEBIRF_INFO_TARGET")

    cat > "$DEBIRF_INFO_TARGET" <<EOF
#!/bin/sh
# this debirf initramfs was generated on $(hostname)
# at $(date -R)

EOF
    debirf_info_comment() {
	echo "$@" | sed 's|^\(.\)|\# \1|' >> "$DEBIRF_INFO_TARGET"
    }
    debirf_info_sh() {
	echo "$@" >> "$DEBIRF_INFO_TARGET"
    }
    export -f debirf_info_comment
    export -f debirf_info_sh
}

create_debootstrap() {
    # include initramfs-tools because they'll be handy
    # exclude aptitude
    mkdir -p "$DEBIRF_ROOT"
    /usr/sbin/debootstrap --exclude=aptitude --include=initramfs-tools "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
}

run_plugins_install() {
    # export all the DEBIRF_* environment variables:
    for var in ${!DEBIRF_*}; do
	export $var
    done
    run-parts --verbose "$DEBIRF_PLUGINS/install"
}

run_plugins_prune() {
    # export all the DEBIRF_* environment variables:
    for var in ${!DEBIRF_*}; do
	export $var
    done
    run-parts --verbose "$DEBIRF_PLUGINS/prune"
}

### stupid simple method
create_initrd_stupid_simple() {
    #ln sbin/init to /init
    ln -sf sbin/init "$DEBIRF_ROOT/init"
    
    # create root image
    msg "creating debirf initrd..."
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) > "$DEBIRF_INITRD"
}

### tweak initrd method
create_initrd_tweak_initrd() {
    cat scripts/debirf <<EOF
mountroot() {
 rootmnt="/"
}
EOF
    cat > bin/run-init <<EOF
#!/bin/sh
if [ "$1" != "/" ] ; then
  exec /usr/lib/klibc/bin/run-init "$@"
else
  MOUNT_POINT="$1"
  INIT="$2"
  shift 2
  exec "$INIT" "$@"
fi
EOF
    # create root image
    msg "creating debirf initrd..."
    cp extra/boot/"$INITRD" debirf.cgz
    (cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) >> "$DEBIRF_INITRD"
}


##### MAIN #####

# create debootstrap root
if [ -d "$DEBIRF_ROOT" ] ; then
    read -p "directory $DEBIRF_ROOT already exists.  write over? [y|N]: " -n 1 OK ; [ -z $OK ] || echo
    if [ "${OK/y/Y}" = 'Y' ] ; then
	msg "installing new root..."
	create_debootstrap
    fi
else
    msg "installing root..."
    create_debootstrap
fi

setup_debirf_info

# mount sys, proc
mount -t proc proc "$DEBIRF_ROOT/proc"
mount -t sysfs sys "$DEBIRF_ROOT/sys"

# update apt
chroot "$DEBIRF_ROOT" apt-get update

# run plugins/install
msg "running install plugins..."
run_plugins_install

# run plugins/prune
msg "running prune plugins..."
run_plugins_prune

# clean apt
chroot "$DEBIRF_ROOT" apt-get clean
rm "$DEBIRF_ROOT/var/cache/apt/"*.bin
rm -rf "$DEBIRF_ROOT/var/lib/apt/lists/"*
mkdir "$DEBIRF_ROOT/var/lib/apt/lists/partial"

# umount sys,proc
umount "$DEBIRF_ROOT/proc"
umount "$DEBIRF_ROOT/sys"

# clear mtab
> "$DEBIRF_ROOT/etc/mtab"
# add proc to fstab
if ! awk '{ print $2 }' < "$DEBIRF_ROOT/etc/fstab" | grep -q '^/proc' ; then
    echo proc /proc proc defaults 0 0 >> "$DEBIRF_ROOT/etc/fstab"
fi

KERNAVAIL=$(ls -1 "$DEBIRF_ROOT/lib/modules" | head -n1)
DEBIRF_INITRD="${DEBIRF_LABEL}_${DEBIRF_DISTRO}_${KERNAVAIL}.cgz"
create_initrd_${DEBIRF_METHOD}

# final output
if [ "$KERNEL" ] ; then
    ln -sf  "extras/boot/$KERNEL" vmlinuz
    msg "kernel: $DEBIRF_PATH/vmlinuz"
fi
msg "initrd: $DEBIRF_PATH/$DEBIRF_INITRD"
