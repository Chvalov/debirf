#!/bin/bash -e

# debirf: script to build debirf system.
#
# The debirf scripts were written by
# Jameson Rollins <jrollins@fifthhorseman.net>
# and
# Daniel Kahn Gillmor <dkg-debian.org@fifthhorseman.net>.
#
# They are Copyright 2007, and are all released under the GPL,
# version 3 or later.

###############################################################
### VARIABLES

CMD=$(basename $0)

DEBIRF_COMMON=${DEBIRF_COMMON:-"/usr/share/debirf/common"}
source "$DEBIRF_COMMON"

# default build type
export ROOT_BUILD=false

# stages to run by default
STAGE_ROOT=true
STAGE_MODULES=true
STAGE_INITRD=true

ROOT_WARNING=true

# location of devices.tar.gz file
export DEVICE_ARCHIVE=/usr/share/debirf/devices.tar.gz

# list of packages to include/exclude from debootstrap
export INCLUDE=less,udhcpc
export EXCLUDE=apt-utils,bsdmainutils,cron,ed,dhcp3-common,dhcp3-client,info,logrotate,man-db,manpages,tasksel,tasksel-data,tcpd,traceroute

###############################################################
### FUNCTIONS

usage() {
    cat <<EOF
Usage: $CMD <subcommand> [options] [args]
Debirf system tool.

subcommands:
  make [options] PROFILE    build debirf profile (make kernel and initramfs)
    -c|--check-vars           check variables before make
    -n|--new                  create new root, even if old one exists
    -o|--overwrite            debootstrap on top of old root if it exists
    -s|--skip                 skip debootstrap step if old root exists
    -r|--root-build           use real chroot to build instead of fakechroot
                              (requires superuser privileges or CAP_SYS_CHROOT)
    -w|--no-warning           skip superuser warning
    -d|--no-initrd            do not make initramfs
    -i|--initrd-only          just remake initramfs from existing root
    -k|--kernel=KERNEL        install KERNEL .deb, instead of default kernel
  enter PROFILE [CMDS]      enter shell in debirf profile root changes
                            (optional execute CMDS in root and exit)
  makeiso PROFILE           create a bootable ISO using the given profile
                            (requires GRUB)
  help                      this help

EOF
}

usage_profile() {
    cat <<EOF
It looks like your profile is not correctly formed.  Please refer to the
README file included with this package on how to setup a profile.
EOF
}

failure() {
    echo "$1" >&2
    exit ${2:-'1'}
}

create_debootstrap() {
    mkdir -p "$DEBIRF_ROOT"
    if [ "$ROOT_BUILD" = 'true' ] ; then
	/usr/sbin/debootstrap --exclude="$EXCLUDE" "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    else
	fakeroot_if_needed fakechroot /usr/sbin/debootstrap --variant=fakechroot --include="$INCLUDE" --exclude="$EXCLUDE" "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    fi
    fakeroot_if_needed mv "$DEBIRF_ROOT"/var/log/bootstrap.log "$DEBIRF_BUILDD"/.bootstrap.log
}

# fix the device tree in the debirf root if fakechroot variant was 
# used with debootstrap (default non-privileged behavior)
fix_dev() {
    if [ -L "$DEBIRF_ROOT"/dev -o ! -d "$DEBIRF_ROOT"/dev ] ; then
	msg "fixing debirf root dev tree..."

        # remove old dev
	fakeroot_if_needed rm -f "$DEBIRF_ROOT"/dev

        # create new dev from devices archive
	fakeroot_if_needed sh -c "cd $DEBIRF_ROOT; tar -xzf $DEVICE_ARCHIVE"

	# create /dev/console
	fakeroot_if_needed sh -c "mknod $DEBIRF_ROOT/dev/console c 5 1; chmod 0600 $DEBIRF_ROOT/dev/console"
    fi
}

# run modules in modules directory
run_modules() {
    fakeroot_if_needed run-parts --verbose --exit-on-error "$DEBIRF_MODULES"
}

# pack the rootfs archive
# takes one input argument as name of output archive file
pack_rootfs() {
    # need to pack archive in fakechroot/chroot so that symlinks correctly
    # point within debirf root, instead of to host path
    fakeroot_if_needed fakechroot chroot "$DEBIRF_ROOT" sh -c "find * | cpio --create -H newc" | gzip > "$1"
}
export -f pack_rootfs


## create_initrd functions
# stupid simple method
create_initrd_stupid_simple() {
    fakeroot_if_needed ln -sf /sbin/init "$DEBIRF_ROOT/init"
    pack_rootfs "$DEBIRF_INITRD"
}

# nested cpio archives
create_initrd_nested() {
    local util lib
    local NEST_ROOT="$DEBIRF_BUILDD"/nest

    # make the nested root
    rm -rf "$NEST_ROOT"
    mkdir -p "$NEST_ROOT"/{bin,lib}

    # copy needed executables into nest
    cp -f /bin/{busybox,cpio} "$NEST_ROOT"/bin/
    for util in awk free grep gunzip ls mkdir mount sh umount ; do
	ln "$NEST_ROOT"/bin/busybox "$NEST_ROOT"/bin/"$util"
    done
    cp -f /usr/lib/klibc/bin/run-init "$NEST_ROOT"/bin/

    # copy in needed libraries
    for lib in $(ldd "$NEST_ROOT"/bin/* | egrep '*.so.[[:digit:]]+ \(0x[[:xdigit:]]{8}\)$' | sed -r 's|.*[[:space:]](/[^[[:space:]]*)[[:space:]]\(0x[[:xdigit:]]{8}\)$|\1|' | sort -u) ; do
	# pull libraries from most basic place libraries can live
	# (avoid arch change between build env and debirf)
	lib=/lib/$(basename "$lib")
	echo -e "$lib\n$(readlink -f $lib)" | cpio --pass-through --make-directories "$NEST_ROOT"/
    done
    cp -f /lib/klibc-* "$NEST_ROOT"/lib/

    # create nest init
    cat > "$NEST_ROOT"/init <<EOF
#!/bin/sh
mkdir /proc
mount -t proc proc /proc
if (grep -q break=top /proc/cmdline); then
  echo "honoring break=top kernel arg"
  /bin/sh
fi
mkdir /newroot
MEMSIZE=\$(free | grep 'Mem:' | awk '{ print \$2 }')
mount -t tmpfs -o size=\${MEMSIZE}k tmpfs /newroot
if (grep -q break=preunpack /proc/cmdline); then
  echo "honoring break=preunpack kernel arg"
  /bin/sh
fi
cd /newroot
echo unpacking rootfs...
# specify /bin/cpio so that it gets used instead of the busybox builtin
# busybox cpio returns "need to fix this" when unpacking hard links
gunzip - < /rootfs.cgz | /bin/cpio -i
if (grep -q break=bottom /proc/cmdline); then
  echo "honoring break=bottom kernel arg"
  /bin/sh
fi
umount /proc
echo running /sbin/init...
exec /bin/run-init . /sbin/init < ./dev/console > ./dev/console
EOF
    chmod a+x "$NEST_ROOT"/init

    msg "creating rootfs.cgz..."
    fakeroot_if_needed ln -sf /sbin/init "$DEBIRF_ROOT/init"
    pack_rootfs "$NEST_ROOT"/rootfs.cgz

    msg "creating wrapper cgz..."
    fakeroot_if_needed sh -c "cd $NEST_ROOT && find * | cpio --create -H newc" | gzip > "$DEBIRF_INITRD"
}

# setup profile environment
setup_environment() {
    # source debirf.conf defaults
    source /usr/share/debirf/debirf.conf.defaults
    
    # check profile
    if [ -d "$DEBIRF_PROFILE" ] ; then
	echo "Loading profile '$DEBIRF_PROFILE'..."
	DEBIRF_CONF="$DEBIRF_PROFILE/debirf.conf"
	DEBIRF_MODULES="$DEBIRF_PROFILE/modules"
    else
	failure "Profile '$DEBIRF_PROFILE' not found."
    fi
    
    # source profile debirf.conf
    if [ -f "$DEBIRF_CONF" ] ; then
	source "$DEBIRF_CONF"
    else
	echo "Configuration file '$DEBIRF_CONF' not found."
	usage_profile
	exit 1
    fi

    # check modules directory
    if [ ! -d "$DEBIRF_MODULES" ] || [ -z "$(ls "$DEBIRF_MODULES")" ] ; then
	echo "Modules directoy '$DEBIRF_MODULES' does not exist or is empty."
	usage_profile
	exit 1
    fi
    for MODULE in $(find "$DEBIRF_MODULES") ; do
	if [ ! -s "$MODULE" ] ; then
	    failure "Module '$MODULE' is a broken link or empty file."
	fi
    done
    
    # check buildd
    if [ -z "$DEBIRF_BUILDD" ] ; then
	failure "DEBIRF_BUILDD is not set."
    fi

    # set root directory
    DEBIRF_ROOT="$DEBIRF_BUILDD/root"

    # set fakechroot save file
    DEBIRF_FAKEROOT_STATE="$DEBIRF_BUILDD/.fakeroot-state.${DEBIRF_LABEL}"

    # export all the DEBIRF_* environment variables:
    for var in ${!DEBIRF_*}; do
	if [ $var ] ; then
	    export $var
	else
	    failure "Variable '$var' not properly set."
	fi
    done
    
    # check variables
    if [ "$CHECK_VARS" ] ; then
	echo "Debirf variables:"
	env | /bin/grep "^DEBIRF_"
	read -p "enter to continue: " OK
    fi
}

# make profile
make() {
    # option parsing
    TEMP=$(getopt --options -hcnosrwdik: --longoptions help,check-vars,new,overwrite,skip,root-build,no-warning,no-initrd,initrd-only,kernel: -n "$CMD" -- "$@")

    if [ $? != 0 ] ; then
	echo "Invalid options." >&2 
	usage
	exit 1
    fi
    
    # Note the quotes around `$TEMP': they are essential!
    eval set -- "$TEMP"

    while true ; do
	case "$1" in
            -c|--check-vars)
		CHECK_VARS=true
		shift 1
		;;
            -n|--new)
		WRITE_MODE=rewrite
		shift 1
		;;
            -o|--overwrite)
		WRITE_MODE=overwrite
		shift 1
		;;
            -s|--skip)
		WRITE_MODE=skip
		shift 1
		;;
            -r|--root-build)
		ROOT_BUILD=true
		shift 1
		;;
            -w|--no-warning)
		ROOT_WARNING=false
		shift 1
		;;
	    -d|--no-initrd)
		STAGE_INITRD=false
		shift 1
		;;
	    -i|--initrd-only)
		STAGE_ROOT=false
		STAGE_MODULES=false
		shift 1
		;;
	    -k|--kernel)
		DEBIRF_KERNEL_PACKAGE="$2"
		shift 2
		;;
            --)
		shift
		;;
            *)
		if (( $# < 1 )) ; then
		    echo "Improper number of input arguments."
		    usage
		    exit 1
		fi
		DEBIRF_PROFILE="$1"
		break
		;;
	esac
    done
    
    if [ $(id -u) = '0' ] ; then
	cat <<EOF
Warning: You are running debirf as root.  There is a potential
for improperly written modules to damage your system.
EOF
	if [ "$ROOT_WARNING" = 'true' ] ; then
	    read -p "Are you sure you wish to continue? [y|N]: " OK; OK=${OK:=N}
	    if [ "${OK/y/Y}" != 'Y' ] ; then
		failure "aborting."
	    fi
	fi
    fi

    setup_environment

    if [ "$DEBIRF_KERNEL_PACKAGE" ] ; then
	if [ -f "$DEBIRF_KERNEL_PACKAGE" ] ; then
	    echo "Using kernel package '$DEBIRF_KERNEL_PACKAGE'."
	else
	    failure "Kernel package '$DEBIRF_KERNEL_PACKAGE' not found."
	fi
    fi
    
    ### BUILD ROOT
    if [ "$STAGE_ROOT" = 'true' ] ; then
        # determine write mode
	if [ -d "$DEBIRF_ROOT" ] ; then
	    if [ -z "$WRITE_MODE" ] ; then
		echo "Debirf root already exists.  Select one of the following:"
		CASE1='new: delete the old root and create a new one'
		CASE2='overwrite: leave the old root and debootstrap on top of it'
		CASE3='skip: skip building the root and go right to installing modules'
		CASE4='exit'
		select CASE in "$CASE1" "$CASE2" "$CASE3" "$CASE4" ; do
		    case "$REPLY" in
			1)
			    WRITE_MODE=rewrite
			    ;;
			2)
			    WRITE_MODE=overwrite
			    ;;
			3)
			    WRITE_MODE=skip
			    ;;
			*)
			    failure "aborting."
			    ;;
		    esac
		    break
		done
	    fi
	else
	    WRITE_MODE=new
	fi
	case "$WRITE_MODE" in
	    'new')
		msg "creating debirf root..."
		> "$DEBIRF_FAKEROOT_STATE"
		create_debootstrap
		;;
	    'rewrite')
		msg "clearing old debirf root..."
		rm -rf "$DEBIRF_ROOT"
		msg "creating debirf root..."
		> "$DEBIRF_FAKEROOT_STATE"
		create_debootstrap
		;;
	    'overwrite')
		msg "overwriting old debirf root..."
		create_debootstrap
		;;
	    'skip')
		msg "skipping debootstrap..."
		;;
	    *)
		failure "aborting."
		;;
	esac
	
        # fix the dev tree if running as non-priv user (fakechroot debootstrap)
	fix_dev
	
    else
	echo "Not building root."
    fi
    ### END BUILD ROOT
    
    ### RUN MODULES
    if [ "$STAGE_MODULES" = 'true' ] ; then
	msg "executing modules..."
	run_modules
	msg "modules complete."
    else
	echo "Not running modules."
    fi
    ### END RUN MODULES

    ### BUILD INITRD
    if [ "$STAGE_INITRD" = 'true' ] ; then
	if [ ! -d "$DEBIRF_ROOT" ] ; then
	    failure "Debirf root '$DEBIRF_ROOT' not found."
	fi
        # determine initrd name
	KERNEL_VERS=$(ls -1 "$DEBIRF_ROOT/lib/modules" | head -n1)
	DEBIRF_INITRD="${DEBIRF_BUILDD}/${DEBIRF_LABEL}_${DEBIRF_DISTRO}_${KERNEL_VERS}.cgz"
	
	msg "creating debirf initrd ('$DEBIRF_METHOD')..."
	create_initrd_${DEBIRF_METHOD} "$DEBIRF_INITRD"
	
        # final output
	DEBIRF_KERNEL=$(ls "$DEBIRF_BUILDD" | grep "vmlinu" | grep "$KERNEL_VERS$")
	msg "debirf initrd created."
	if [ "$DEBIRF_BUILDD/$DEBIRF_KERNEL" ] ; then
	    msg "kernel: $DEBIRF_BUILDD/$DEBIRF_KERNEL"
	fi
	msg "initrd: $DEBIRF_INITRD"
    else
	echo "Not creating initramfs."
    fi
    ### END BUILD INITRD
}

# enter profile root
enter() {
    DEBIRF_PROFILE="$1"
    shift

    setup_environment

    if [ "$1" ] ; then
	fakeroot_if_needed debirf_exec "$@"
    else
	fakeroot_if_needed debirf_exec bash -i
    fi
}

# create an ISO from the given kernel and initramfs (requires GRUB,
# see:
# http://www.gnu.org/software/grub/manual/html_node/Making-a-GRUB-bootable-CD-ROM.html)
makeiso() {
    DEBIRF_PROFILE="$1"
    shift
    [ -d "$DEBIRF_PROFILE" ] || failure "'$DEBIRF_PROFILE' does not seem to be a directory"

    cd "$DEBIRF_PROFILE" || failure "Could not enter profile directory '$DEBIRF_PROFILE'."
    local KERNEL=${KERNEL:-$(echo "vmlinu"*)}
    local INITRAMFS=${INITRAMFS:-$(echo "debirf-"*.cgz)}

    # FIXME: it would be best to pull the name of the architecture
    # exactly instead of using shell globbing to guess at it:
    local GRUB_ELTORITO=${GRUB_ELTORITO:-$(echo "/usr/lib/grub/"*"-pc/stage2_eltorito")}

    ls -l "$KERNEL" > /dev/null || failure "Failed to find a single kernel in '$DEBIRF_PROFILE'"
    ls -l "$INITRAMFS" > /dev/null || failure "Failed to find a single initramfs in '$DEBIRF_PROFILE'"
    [ -r "$GRUB_ELTORITO" ] || failure "Failed to find a grub El Torito stage2 loader."

    # get rid of the "iso" directory if it exists.
    rm -rf iso
    mkdir -p iso/boot/grub

    # use hard links to avoid massive copying time and mkisofs's
    # warning about -f (we're almost certainly on the same filesystem):
    ln "$KERNEL" iso/ || failure "Failed to link kernel into iso"
    ln "$INITRAMFS" iso/ || failure "Failed to link initramfs into iso"

    # this file is very likely not on the same filesystem (and it's
    # likely to be small) so copying it makes more sense than linking:
    cp "$GRUB_ELTORITO" iso/boot/grub/
    cat >iso/boot/grub/menu.lst <<EOF
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1
terminal --timeout=10 serial console

title        Debirf ($DEBIRF_PROFILE) (created $(date -R))
kernel       /$KERNEL
initrd       /$INITRAMFS
EOF

    mkisofs -R -b boot/grub/stage2_eltorito -no-emul-boot -boot-load-size 4 -boot-info-table -o "debirf-$DEBIRF_PROFILE.iso" iso
    # do we need to clean up the iso/ directory so that this can be run again?    
}


###############################################################
### MAIN

COMMAND="$1"
[ "$COMMAND" ] || failure "Type '$CMD help' for usage."
shift

case $COMMAND in
    'make'|'m')
        make "$@"
        ;;
    'makeiso'|'i')
        makeiso "$@"
        ;;
    'enter'|'e')
        enter "$@"
        ;;
    'help'|'h'|'?')
        usage
        ;;
    *)
        failure "Unknown command: '$COMMAND'
Type '$CMD help' for usage."
        ;;
esac
