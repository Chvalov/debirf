#!/bin/bash -e

# make-debirf: script to build debirf system.
#
# The debirf scripts were written by
# Jameson Rollins <jrollins@fifthhorseman.net>
# and
# Daniel Kahn Gillmor <dkg-debian.org@fifthhorseman.net>.
#
# They are Copyright 2007, and are all released under the GPL,
# version 3 or later.

###############################################################
### VARIABLES

CMD=$(basename $0)

DEBIRF_COMMON=${DEBIRF_COMMON:-"/usr/share/debirf/common"}
source "$DEBIRF_COMMON"

# default build type
export ROOT_BUILD=false

# stages to run by default
STAGE_ROOT=true
STAGE_MODULES=true
STAGE_INITRD=true

ROOT_WARNING=true

# list of packages to exclude from debootstrap
export EXCLUDE=cron,ed,logrotate,tasksel-data,tcpd

###############################################################
### FUNCTIONS

usage() {
    cat <<EOF
Usage: $CMD [options] profile
Create a debirf system.  The 'profile' is a path to a debirf profile
directory.

options:
  -h|--help               this help message
  -c|--check-vars         check variables before make
  -n|--new                create new root, even if old one exists
  -o|--overwrite          debootstrap on top of old root if it exists
  -s|--skip               skip debootstrap step if old root exists
  -r|--root-build         use real chroot to build instead of fakechroot
                          (requires superuser privileges or CAP_SYS_CHROOT)
  -w|--no-warning         skip superuser warning
  -i|--initrd-only        remake initramfs from existing root
  -k|--kernel=KERNEL      install KERNEL .deb, instead of default kernel
EOF
}

usage_profile() {
    cat <<EOF
It looks like your profile is not correctly formed.  You should begin
by copying and modifying one of the example debirf profiles.
On Debian, you can copy them from the debirf docs:
cp -r /usr/share/doc/debirf/example-profiles/<profile-name> . 
EOF
}

failure() {
    echo "$1" >&2
    exit ${2:-'1'}
}

create_debootstrap() {
    mkdir -p "$DEBIRF_ROOT"
    if [ "$ROOT_BUILD" = 'true' ] ; then
	/usr/sbin/debootstrap --exclude="$EXCLUDE" "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    else
	fakeroot_if_needed fakechroot /usr/sbin/debootstrap --variant=fakechroot --exclude="$EXCLUDE" "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    fi
}

# fix the device tree in the debirf root if fakechroot variant was 
# used with debootstrap (default non-privileged behavior)
fix_dev() {
    if [ -L "$DEBIRF_ROOT"/dev -o ! -d "$DEBIRF_ROOT"/dev ] ; then
	msg "fixing debirf root dev tree..."

        # remove old dev
	fakeroot_if_needed rm -f "$DEBIRF_ROOT"/dev

        # create new dev based on dev archive that comes with debootstrap
	fakeroot_if_needed sh -c "cd $DEBIRF_ROOT; tar -xzf /usr/lib/debootstrap/devices.tar.gz"

	# create /dev/console, since it's not included by default
	fakeroot_if_needed sh -c "mknod $DEBIRF_ROOT/dev/console c 5 1; chmod 0600 $DEBIRF_ROOT/dev/console"
    fi
}
export -f fix_dev

run_modules() {
    # export all the DEBIRF_* environment variables:
    for var in ${!DEBIRF_*}; do
	export $var
    done
    fakeroot_if_needed run-parts --verbose "$DEBIRF_MODULES"
}

# pack the rootfs archive
# takes one input argument as name of output archive file
pack_rootfs() {
    # need to pack archive in fakechroot/chroot so that symlinks correctly
    # point within debirf root, instead of to host path
    fakeroot_if_needed fakechroot chroot "$DEBIRF_ROOT" sh -c "find * | cpio --create -H newc" | gzip > "$1"
}
export -f pack_rootfs


## create_initrd functions
# stupid simple method
create_initrd_stupid_simple() {
    fakeroot_if_needed ln -sf /sbin/init "$DEBIRF_ROOT/init"
    pack_rootfs "$DEBIRF_INITRD"
}

# nested cpio archives
create_initrd_nested() {
    local util lib
    local NEST_ROOT="$DEBIRF_BUILDD"/nest

    # make the nested root
    rm -rf "$NEST_ROOT"
    mkdir -p "$NEST_ROOT"/{bin,lib}

    # copy needed executables into nest
    cp -f /bin/{busybox,cpio} "$NEST_ROOT"/bin/
    for util in sh mkdir mount ls gunzip grep awk free ; do
	ln "$NEST_ROOT"/bin/busybox "$NEST_ROOT"/bin/"$util"
    done
    cp -f /usr/lib/klibc/bin/run-init "$NEST_ROOT"/bin/

    # copy in needed libraries
    for lib in $(ldd "$NEST_ROOT"/bin/* | egrep '*.so.[[:digit:]]+ \(0x[[:xdigit:]]{8}\)$' | sed -r 's|.*[[:space:]](/[^[[:space:]]*)[[:space:]]\(0x[[:xdigit:]]{8}\)$|\1|' | sort -u) ; do
	# pull libraries from most basic place libraries can live
	# (avoid arch change between build env and debirf)
	lib=/lib/$(basename "$lib")
	echo -e "$lib\n$(readlink -f $lib)" | cpio --pass-through --make-directories "$NEST_ROOT"/
    done
    cp -f /lib/klibc-* "$NEST_ROOT"/lib/

    # create nest init
    cat > "$NEST_ROOT"/init <<EOF
#!/bin/sh
mkdir /newroot
MEMSIZE=\$(free | grep 'Mem:' | awk '{ print \$2 }')
mount -t tmpfs -o size=\${MEMSIZE}k tmpfs /newroot
cd /newroot
echo unpacking rootfs...
# specify /bin/cpio so that it gets used instead of the busybox builtin
# busybox cpio returns "need to fix this" when unpacking hard links
gunzip - < /rootfs.cgz | /bin/cpio -i
echo running /sbin/init...
exec /bin/run-init . /sbin/init < ./dev/console > ./dev/console
EOF
    chmod a+x "$NEST_ROOT"/init

    msg "creating rootfs.cgz..."
    fakeroot_if_needed ln -sf /sbin/init "$DEBIRF_ROOT/init"
    pack_rootfs "$NEST_ROOT"/rootfs.cgz

    msg "creating wrapper cgz..."
    fakeroot_if_needed sh -c "cd $NEST_ROOT && find * | cpio --create -H newc" | gzip > "$DEBIRF_INITRD"
}

# tweak initrd method: untested, probably doesn't work right yet.  soon!
# NONFUNCTIONING
create_initrd_tweak_initrd() {
    cat "$DEBIRF_ROOT/scripts/debirf" <<EOF
mountroot() {
 rootmnt="/"
}
EOF
    cat > "$DEBIRF_ROOT/bin/run-init" <<EOF
#!/bin/sh
if [ "$1" != "/" ] ; then
  exec /usr/lib/klibc/bin/run-init "$@"
else
  MOUNT_POINT="$1"
  INIT="$2"
  shift 2
  exec "$INIT" "$@"
fi
EOF
    # create root image
    cp initrd.img* "$1"
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) >> "$1"
}

# unionfs method: also untested and probably not working.
# NONFUNCTIONING
create_initrd_unionfs() {
    #ln sbin/init to /init
    ln -sf /sbin/init "$DEBIRF_ROOT/init"
    
    # add unionfs kernel module and init script
    debirf_exec apt-get update
    debirf_exec apt-get install unionfs-modules-"$KERNAVAIL" unionfs-tools

    cat >"$DEBIRF_ROOT/etc/init.d/root-unionfs" <<EOF
#!/bin/bash

mount -t tmpfs tmpfs /tmp
mount -t unionfs dirs=/=ro:/tmp=rw unionfs /
EOF

    ln -sf ../init.d/root-unionfs /etc/rcS.d/S00root-unionfs

    # create root image
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) > "$1"
}

###############################################################
### MAIN

# option parsing
TEMP=$(getopt --options -hcnosrwik: --longoptions help,check-vars,new,overwrite,skip,root-build,no-warning,initrd-only,kernel: -n "$CMD" -- "$@")

if [ $? != 0 ] ; then
    echo "Invalid options." >&2 
    usage
    exit 1
fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true ; do
    case "$1" in
        -h|--help)
	    usage
	    exit 0
            ;;
        -c|--check-vars)
            CHECK_VARS=true
            shift 1
            ;;
        -n|--new)
            WRITE_MODE=rewrite
            shift 1
            ;;
        -o|--overwrite)
            WRITE_MODE=overwrite
            shift 1
            ;;
        -s|--skip)
            WRITE_MODE=skip
            shift 1
            ;;
        -r|--root-build)
	    ROOT_BUILD=true
            shift 1
            ;;
        -w|--no-warning)
	    ROOT_WARNING=false
	    shift 1
	    ;;
	-i|--initrd-only)
	    STAGE_ROOT=false
	    STAGE_MODULES=false
	    shift 1
	    ;;
	-k|--kernel)
	    DEBIRF_KERNEL_PACKAGE="$2"
	    shift 2
	    ;;
        --)
            shift
            ;;
        *)
	    if (( $# < 1 )) ; then
		echo "Improper number of input arguments."
		usage
		exit 1
            fi
	    DEBIRF_PROFILE="$1"
            break
            ;;
    esac
done

if [ $(id -u) = '0' ] ; then
    cat <<EOF
Warning: You are running make-debirf as root.  There is a potential
for improperly written modules to damage your system.
EOF
    if [ "$ROOT_WARNING" = 'true' ] ; then
	read -p "Are you sure you wish to continue? [y|N]: " OK; OK=${OK:=N}
	if [ "${OK/y/Y}" != 'Y' ] ; then
	    failure "aborting."
	fi
    fi
fi

if [ "$DEBIRF_KERNEL_PACKAGE" ] ; then
    if [ -f "$DEBIRF_KERNEL_PACKAGE" ] ; then
	echo "Using kernel package '$DEBIRF_KERNEL_PACKAGE'."
    else
	failure "Kernel package '$DEBIRF_KERNEL_PACKAGE' not found."
    fi
fi

# source debirf.conf defaults
source /usr/share/debirf/debirf.conf.defaults

# check profile
if [ -d "$DEBIRF_PROFILE" ] ; then
    echo "Loading profile '$DEBIRF_PROFILE'..."
    DEBIRF_CONF="$DEBIRF_PROFILE/debirf.conf"
    DEBIRF_MODULES="$DEBIRF_PROFILE/modules"
else
    echo "Profile '$DEBIRF_PROFILE' not found."
    usage_profile
    exit 1
fi

# source profile debirf.conf
if [ -f "$DEBIRF_CONF" ] ; then
    source "$DEBIRF_CONF"
else
    echo "$DEBIRF_CONF not found."
    usage_profile
    exit 1
fi

# check modules directory
if [ ! -d "$DEBIRF_MODULES" ] ; then
    echo "$DEBIRF_MODULES does not exist."
    usage_profile
    exit 1
fi
if [ $(ls "$DEBIRF_MODULES" -1 | wc -l) = 0 ] ; then
    echo "$DEBIRF_MODULES is empty."
    usage_profile
    exit 1
fi

# check buildd
if [ -z "$DEBIRF_BUILDD" ] ; then
    failure "DEBIRF_BUILDD is not set."
fi

# check debirf root
if [ -z "$DEBIRF_ROOT" ] ; then
    failure "DEBIRF_ROOT is not set."
fi

# set fakechroot save file
DEBIRF_FAKEROOT_STATE="$DEBIRF_BUILDD/.fakeroot-${DEBIRF_LABEL}.save"
if [ "$ROOT_BUILD" != 'true' ] ; then
    > "$DEBIRF_FAKEROOT_STATE"
fi

# check variables
if [ "$CHECK_VARS" ] ; then
    echo "Debirf variables:"
    for var in ${!DEBIRF_*}; do
	if [ $var ] ; then
	    export $var
	else
	    failure "Variable '$var' not properly set."
	fi
    done
    env | /bin/grep "^DEBIRF_"
    read -p "enter to continue: " OK
fi

### BUILD ROOT
if [ "$STAGE_ROOT" = 'true' ] ; then

# determine write mode
if [ -d "$DEBIRF_ROOT" ] ; then
    echo "Debirf root '$DEBIRF_ROOT' already exists."
    if [ -z "$WRITE_MODE" ] ; then
	echo "Select one of the following:"
	select foo in 'new' 'overwrite' 'skip' 'exit' ; do
	    case "$foo" in
		'new')
		    WRITE_MODE=rewrite
		    ;;
		'overwrite')
		    WRITE_MODE=overwrite
		    ;;
		'skip')
		    WRITE_MODE=skip
		    ;;
		*)
		    failure "aborting."
		    ;;
	    esac
	    break
	done
    fi
else
    WRITE_MODE=new
fi
case "$WRITE_MODE" in
    'new')
	msg "creating debirf root..."
	create_debootstrap
	;;
    'rewrite')
	msg "clearing old debirf root..."
	rm -rf "$DEBIRF_ROOT"
	msg "creating debirf root..."
	create_debootstrap
	;;
    'overwrite')
	msg "overwriting old debirf root..."
	create_debootstrap
	;;
    'skip')
	msg "skipping debootstrap..."
	;;
    *)
	failure "aborting."
	;;
esac

# fix the dev tree if running as non-priv user (fakechroot debootstrap)
fix_dev

else
    echo "Not building root."
fi
### END BUILD ROOT

### RUN MODULES
if [ "$STAGE_MODULES" = 'true' ] ; then
    msg "executing modules..."
    run_modules
    msg "modules complete."
else
    echo "Not running modules."
fi
### END RUN MODULES

### BUILD INITRD
if [ "$STAGE_INITRD" = 'true' ] ; then
    if [ ! -d "$DEBIRF_ROOT" ] ; then
	failure "Debirf root '$DEBIRF_ROOT' not found."
    fi
    # determine initrd name
    KERNEL_VERS=$(ls -1 "$DEBIRF_ROOT/lib/modules" | head -n1)
    DEBIRF_INITRD="${DEBIRF_BUILDD}/${DEBIRF_LABEL}_${DEBIRF_DISTRO}_${KERNEL_VERS}.cgz"

    msg "creating debirf initrd ('$DEBIRF_METHOD')..."
    create_initrd_${DEBIRF_METHOD} "$DEBIRF_INITRD"

    # final output
    DEBIRF_KERNEL=$(ls "$DEBIRF_BUILDD" | grep "vmlinu" | grep "$KERNEL_VERS$")
    msg "debirf initrd created."
    if [ "$DEBIRF_BUILDD/$DEBIRF_KERNEL" ] ; then
	msg "kernel: $DEBIRF_BUILDD/$DEBIRF_KERNEL"
    fi
    msg "initrd: $DEBIRF_INITRD"
else
    echo "Not creating initramfs."
fi
### END BUILD INITRD
