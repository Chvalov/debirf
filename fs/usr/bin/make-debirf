#!/bin/bash -e

# make-debirf: script to build debirf system.
#
# The debirf scripts were written by
# Jameson Rollins <jrollins@fifthhorseman.net>
# and
# Daniel Kahn Gillmor <dkg-debian.org@fifthhorseman.net>.
#
# They are Copyright 2007, and are all released under the GPL, version 2
# or later.

###############################################################
### VARIABLES

CMD=$(basename $0)

DEBIRF_COMMON=${DEBIRF_COMMON:-"/usr/share/debirf/common"}
source "$DEBIRF_COMMON"

export FAKECHROOT_BUILD=false
STAGE_ROOT=true
STAGE_PLUGINS=true
STAGE_INITRD=true

###############################################################
### FUNCTIONS

usage() {
    cat <<EOF
Usage: $CMD [options] profile kernel
Create a debirf system.  'profile' is a path to a debirf profile
directory, and 'kernel' is a kernel-img .deb, or a kernel package name.

options:
  -h|--help          this help message
  -f|--fakechroot    fakechroot build (other wise requires being root)
  -c|--check-vars    check variables before make
  -n|--new           create new root, even if old one exists
  -o|--overwrite     debootstrap on top of old root if it exists
  -s|--skip          skip debootstrap step if old root exists
  -i|--initrd-only   do not create root, just create initramfs
EOF
}

failure() {
    echo "$1" >&2
    exit ${2:-'1'}
}

create_debootstrap() {
    mkdir -p "$DEBIRF_ROOT"
    if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
	fakeroot -s "$DEBIRF_FAKEROOT_STATE" fakechroot /usr/sbin/debootstrap --variant=fakechroot "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    else
	/usr/sbin/debootstrap "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    fi
}

run_plugins() {
    # export all the DEBIRF_* environment variables:
    for var in ${!DEBIRF_*}; do
	export $var
    done
    if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
	fakeroot -i "$DEBIRF_FAKEROOT_STATE" -s "$DEBIRF_FAKEROOT_STATE" run-parts --verbose "$DEBIRF_PLUGINS"
    else
	run-parts --verbose "$DEBIRF_PLUGINS"
    fi
}

## create_initrd functions take the name of the targeted initrd as
## their first argument.
# stupid simple method
create_initrd_stupid_simple() {
    #ln sbin/init to /init
    ln -sf /sbin/init "$DEBIRF_ROOT/init"

    if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
        # create a proper dev tree, based on the host systems dev tree
	fakeroot -i "$DEBIRF_FAKEROOT_STATE" -s "$DEBIRF_FAKEROOT_STATE" bash -c 'rm -rf '"$DEBIRF_ROOT"'/dev; (cd / && find dev | cpio --create) | (cd '"$DEBIRF_ROOT"'/ && cpio --extract)'    
        #fakeroot -i "$DEBIRF_FAKEROOT_STATE" -s "$DEBIRF_FAKEROOT_STATE" bash -c 'rm -rf '"$DEBIRF_ROOT"'/dev; mkdir '"$DEBIRF_ROOT"'/dev'

        # create root image
	( cd "$DEBIRF_ROOT" && find * | fakeroot cpio --create -H newc | gzip ) > "$1"
    else
        # create root image
	( cd "$DEBIRF_ROOT" && find * | cpio --create -H newc | gzip ) > "$1"
    fi
}

# nested cpio archives
create_initrd_nested() {
    local util lib
    local NEST_ROOT="$DEBIRF_BUILDD"/nest

    # make the nested root
    rm -rf "$NEST_ROOT"
    mkdir -p "$NEST_ROOT"/{bin,lib}

    # copy needed executables into nest
    cp -f /bin/{busybox,cpio} "$NEST_ROOT"/bin/
    for util in sh mkdir mount ls gunzip ; do
	ln "$NEST_ROOT"/bin/busybox "$NEST_ROOT"/bin/"$util"
    done
    cp -f /usr/lib/klibc/bin/run-init "$NEST_ROOT"/bin/

    # copy in needed libraries
    for lib in $(ldd "$NEST_ROOT"/bin/* | egrep '*.so.[[:digit:]]+ \(0x[[:xdigit:]]{8}\)$' | sed -r 's|.*[[:space:]](/[^[[:space:]]*)[[:space:]]\(0x[[:xdigit:]]{8}\)$|\1|' | sort -u) ; do
	# pull libraries from most basic place libraries can live
	# (avoid arch change between build env and debirf)
	lib=/lib/$(basename "$lib")
	echo -e "$lib\n$(readlink -f $lib)" | cpio --pass-through --make-directories "$NEST_ROOT"/
    done
    cp -f /lib/klibc-* "$NEST_ROOT"/lib/

    # create nest init
    cat > "$NEST_ROOT"/init <<EOF
#!/bin/sh
mkdir /newroot
mount -t tmpfs tmpfs /newroot
cd /newroot
# specify /bin/cpio so that it gets used instead of the busybox builtin
gunzip - </rootfs.cgz | /bin/cpio -i
echo unpacking rootfs...
exec /bin/run-init . /sbin/init <./dev/console >./dev/console
EOF
    chmod a+x "$NEST_ROOT"/init

    msg "creating rootfs.cgz..."
    create_initrd_stupid_simple "$NEST_ROOT"/rootfs.cgz

    msg "creating wrapper cgz..."
    ( cd "$NEST_ROOT" && find * | fakeroot cpio --create -H newc | gzip ) > "$1"
}

# tweak initrd method: untested, probably doesn't work right yet.  soon!
create_initrd_tweak_initrd() {
    cat "$DEBIRF_ROOT/scripts/debirf" <<EOF
mountroot() {
 rootmnt="/"
}
EOF
    cat > "$DEBIRF_ROOT/bin/run-init" <<EOF
#!/bin/sh
if [ "$1" != "/" ] ; then
  exec /usr/lib/klibc/bin/run-init "$@"
else
  MOUNT_POINT="$1"
  INIT="$2"
  shift 2
  exec "$INIT" "$@"
fi
EOF
    # create root image
    cp initrd.img* "$1"
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) >> "$1"
}

# unionfs method: also untested and probably not working.
create_initrd_unionfs() {
    #ln sbin/init to /init
    ln -sf /sbin/init "$DEBIRF_ROOT/init"
    
    # add unionfs kernel module and init script
    debirf_exec apt-get update
    debirf_exec apt-get install unionfs-modules-"$KERNAVAIL" unionfs-tools

    cat >"$DEBIRF_ROOT/etc/init.d/root-unionfs" <<EOF
#!/bin/bash

mount -t tmpfs tmpfs /tmp
mount -t unionfs dirs=/=ro:/tmp=rw unionfs /
EOF

    ln -sf ../init.d/root-unionfs /etc/rcS.d/S00root-unionfs

    # create root image
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) > "$1"
}

###############################################################
### MAIN

# option parsing
TEMP=$(getopt --options -hfcnosi --longoptions help,fakechroot,check-vars,new,overwrite,skip,initrd-only -n "$CMD" -- "$@")

if [ $? != 0 ] ; then
    echo "Invalid options." >&2 
    usage
    exit 1
fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true ; do
    case "$1" in
        -h|--help)
	    usage
	    exit 0
            ;;
        -f|--fakechroot)
	    echo "Using fakechroot build."
	    FAKECHROOT_BUILD=true
            shift 1
            ;;
        -c|--check-vars)
            CHECK_VARS=true
            shift 1
            ;;
        -n|--new)
            WRITE_MODE=rewrite
            shift 1
            ;;
        -o|--overwrite)
            WRITE_MODE=overwrite
            shift 1
            ;;
        -s|--skip)
            WRITE_MODE=skip
            shift 1
            ;;
	-i|--initrd-only)
	    STAGE_ROOT=false
	    STAGE_PLUGINS=false
	    shift 1
	    ;;
        --)
            shift
            ;;
        *)
	    if (( $# < 1 )) ; then
		echo "Improper number of input arguments."
		usage
		exit 1
            fi
	    DEBIRF_PROFILE="$1"
	    DEBIRF_KERNEL_PACKAGE="$2"
            break
            ;;
    esac
done

# source debirf.conf defaults
source /usr/share/debirf/debirf.conf.defaults

# check profile
if [ -d "$DEBIRF_PROFILE" ] ; then
    echo "Loading profile '$DEBIRF_PROFILE'..."
    DEBIRF_CONF="$DEBIRF_PROFILE/debirf.conf"
    DEBIRF_PLUGINS="$DEBIRF_PROFILE/plugins"
else
    failure "$DEBIRF_PROFILE not found.  Create a new profile with the '-p' option."
fi

# source profile debirf.conf
if [ -f "$DEBIRF_CONF" ] ; then
    source "$DEBIRF_CONF"
else
    failure "$DEBIRF_CONF not found."
fi

# check plugins directory
if [ ! -d "$DEBIRF_PLUGINS" ] ; then
    failure "$DEBIRF_PLUGINS does not exist."
fi
if [ $(ls "$DEBIRF_PLUGINS" -1 | wc -l) = 0 ] ; then
    failure "$DEBIRF_PLUGINS is empty."
fi

# check buildd
if [ -z "$DEBIRF_BUILDD" ] ; then
    failure "DEBIRF_BUILDD is not set."
fi

# check debirf root
if [ -z "$DEBIRF_ROOT" ] ; then
    failure "DEBIRF_ROOT is not set."
fi

# set fakechroot save file
DEBIRF_FAKEROOT_STATE="$DEBIRF_BUILDD/.fakechroot-$DEBIRF_LABEL.save"

# check variables
if [ "$CHECK_VARS" ] ; then
    echo "Debirf variables:"
    for var in ${!DEBIRF_*}; do
	if [ $var ] ; then
	    export $var
	else
	    failure "Variable '$var' not properly set."
	fi
    done
    env | /bin/grep "^DEBIRF_"
    read -p "enter to continue: " OK
fi

### BUILD ROOT
if [ "$STAGE_ROOT" = 'true' ] ; then

# check specified kernel package exists
if [ ! -f "$DEBIRF_KERNEL_PACKAGE" ] ; then
    if apt-cache show "$DEBIRF_KERNEL_PACKAGE" > /dev/null ; then
	echo "Using apt kernel package '$DEBIRF_KERNEL_PACKAGE'."
    else
	failure "Specified kernel package '$DEBIRF_KERNEL_PACKAGE' not found."
    fi
fi

# determine write mode
if [ -d "$DEBIRF_ROOT" ] ; then
    echo "Directory $DEBIRF_ROOT already exists."
    if [ -z "$WRITE_MODE" ] ; then
	echo "Select one of the following:"
	select foo in 'new' 'overwrite' 'skip' 'exit' ; do
	    case "$foo" in
		'new')
		    WRITE_MODE=rewrite
		    ;;
		'overwrite')
		    WRITE_MODE=overwrite
		    ;;
		'skip')
		    WRITE_MODE=skip
		    ;;
		*)
		    failure "aborting."
		    ;;
	    esac
	    break
	done
    fi
else
    WRITE_MODE=new
fi
case "$WRITE_MODE" in
    'new')
	msg "creating debirf root..."
	create_debootstrap
	;;
    'rewrite')
	msg "clearing old debirf root..."
	rm -rf "$DEBIRF_ROOT"
	msg "creating debirf root..."
	create_debootstrap
	;;
    'overwrite')
	msg "overwriting old debirf root..."
	create_debootstrap
	;;
    'skip')
	msg "skipping debootstrap..."
	;;
    *)
	failure "aborting."
	;;
esac
else
    echo "Not building root."
fi
### END BUILD ROOT


### RUN PLUGINS
if [ "$STAGE_PLUGINS" = 'true' ] ; then
    setup_debirf_info
    msg "executing plugins..."
    run_plugins
    msg "plugins complete."
else
    echo "Not running plugins."
fi
### END RUN PLUGINS


### BUILD INITRD
if [ "$STAGE_INITRD" = 'true' ] ; then
    if [ ! -d "$DEBIRF_ROOT" ] ; then
	failure "Root not found."
    fi
    # determine initrd name
    KERNEL_VERS=$(ls -1 "$DEBIRF_ROOT/lib/modules" | head -n1)
    DEBIRF_INITRD="${DEBIRF_LABEL}_${DEBIRF_DISTRO}_${KERNEL_VERS}.cgz"

    msg "creating debirf initrd ('$DEBIRF_METHOD')..."
    create_initrd_${DEBIRF_METHOD} "$DEBIRF_BUILDD/$DEBIRF_INITRD"

    # final output
    DEBIRF_KERNEL=$(ls "$DEBIRF_BUILDD" | grep "vmlinu" | grep "$KERNEL_VERS$")
    msg "debirf initrd created."
    if [ "$DEBIRF_BUILDD/$DEBIRF_KERNEL" ] ; then
	msg "kernel: $DEBIRF_BUILDD/$DEBIRF_KERNEL"
    fi
    msg "initrd: $DEBIRF_BUILDD/$DEBIRF_INITRD"
else
    echo "Not creating initramfs."
fi
### END BUILD INITRD
