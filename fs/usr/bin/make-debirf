#!/bin/bash -e

# make-debirf: script to build debirf system.
#
# The debirf scripts were written by
# Jameson Rollins <jrollins@fifthhorseman.net>
# and
# Daniel Kahn Gillmor <dkg-debian.org@fifthhorseman.net>.
#
# They are Copyright 2007, and are all released under the GPL,
# version 3 or later.

###############################################################
### VARIABLES

CMD=$(basename $0)

DEBIRF_COMMON=${DEBIRF_COMMON:-"/usr/share/debirf/common"}
source "$DEBIRF_COMMON"

export FAKECHROOT_BUILD=false
STAGE_ROOT=true
STAGE_PLUGINS=true
STAGE_INITRD=true

###############################################################
### FUNCTIONS

usage() {
    cat <<EOF
Usage: $CMD [options] profile
Create a debirf system.  The 'profile' is a path to a debirf profile
directory.  make-debirf requires superuser privileges for the debootstrap
stage, unless the '-f' option is given (still experimental).

options:
  -h|--help               this help message
  -f|--fakechroot         fakechroot build
  -c|--check-vars         check variables before make
  -n|--new                create new root, even if old one exists
  -o|--overwrite          debootstrap on top of old root if it exists
  -s|--skip               skip debootstrap step if old root exists
  -i|--initrd-only        remake initramfs from existing root
  -k|--kernel-deb=KERNEL  install KERNEL .deb, instead of default kernel
EOF
}

usage_profile() {
    cat <<EOF
It looks like your profile is not correctly formed.  You should begin
by copying and modifying one of the example debirf profiles.
On Debian, you can copy them from the debirf docs:
cp -r /usr/share/doc/debirf/example-profiles/<profile-name> . 
EOF
}

failure() {
    echo "$1" >&2
    exit ${2:-'1'}
}

create_debootstrap() {
    mkdir -p "$DEBIRF_ROOT"
    if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
	fakeroot -s "$DEBIRF_FAKEROOT_STATE" fakechroot /usr/sbin/debootstrap --variant=fakechroot "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    else
	/usr/sbin/debootstrap "$DEBIRF_DISTRO" "$DEBIRF_ROOT" "$DEBIRF_MIRROR"
    fi
}

run_plugins() {
    # export all the DEBIRF_* environment variables:
    for var in ${!DEBIRF_*}; do
	export $var
    done
    if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
	fakeroot -i "$DEBIRF_FAKEROOT_STATE" -s "$DEBIRF_FAKEROOT_STATE" run-parts --verbose "$DEBIRF_PLUGINS"
    else
	run-parts --verbose "$DEBIRF_PLUGINS"
    fi
}

## create_initrd functions take the name of the targeted initrd as
## their first argument.
# stupid simple method
create_initrd_stupid_simple() {
    #ln sbin/init to /init
    ln -sf /sbin/init "$DEBIRF_ROOT/init"

    if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
        # create a proper dev tree, based on the host systems dev tree
	fakeroot -i "$DEBIRF_FAKEROOT_STATE" -s "$DEBIRF_FAKEROOT_STATE" bash -c 'rm -rf '"$DEBIRF_ROOT"'/dev; (cd / && find dev | cpio --create) | (cd '"$DEBIRF_ROOT"'/ && cpio --extract)'    
        #fakeroot -i "$DEBIRF_FAKEROOT_STATE" -s "$DEBIRF_FAKEROOT_STATE" bash -c 'rm -rf '"$DEBIRF_ROOT"'/dev; mkdir '"$DEBIRF_ROOT"'/dev'

        # create root image
	( cd "$DEBIRF_ROOT" && find * | fakeroot cpio --create -H newc | gzip ) > "$1"
    else
        # create root image
	( cd "$DEBIRF_ROOT" && find * | cpio --create -H newc | gzip ) > "$1"
    fi
}

# nested cpio archives
create_initrd_nested() {
    local util lib
    local NEST_ROOT="$DEBIRF_BUILDD"/nest

    # make the nested root
    rm -rf "$NEST_ROOT"
    mkdir -p "$NEST_ROOT"/{bin,lib}

    # copy needed executables into nest
    cp -f /bin/{busybox,cpio} "$NEST_ROOT"/bin/
    for util in sh mkdir mount ls gunzip ; do
	ln "$NEST_ROOT"/bin/busybox "$NEST_ROOT"/bin/"$util"
    done
    cp -f /usr/lib/klibc/bin/run-init "$NEST_ROOT"/bin/

    # copy in needed libraries
    for lib in $(ldd "$NEST_ROOT"/bin/* | egrep '*.so.[[:digit:]]+ \(0x[[:xdigit:]]{8}\)$' | sed -r 's|.*[[:space:]](/[^[[:space:]]*)[[:space:]]\(0x[[:xdigit:]]{8}\)$|\1|' | sort -u) ; do
	# pull libraries from most basic place libraries can live
	# (avoid arch change between build env and debirf)
	lib=/lib/$(basename "$lib")
	echo -e "$lib\n$(readlink -f $lib)" | cpio --pass-through --make-directories "$NEST_ROOT"/
    done
    cp -f /lib/klibc-* "$NEST_ROOT"/lib/

    # create nest init
    cat > "$NEST_ROOT"/init <<EOF
#!/bin/sh
mkdir /newroot
mount -t tmpfs tmpfs /newroot
cd /newroot
# specify /bin/cpio so that it gets used instead of the busybox builtin
gunzip - </rootfs.cgz | /bin/cpio -i
echo unpacking rootfs...
exec /bin/run-init . /sbin/init <./dev/console >./dev/console
EOF
    chmod a+x "$NEST_ROOT"/init

    msg "creating rootfs.cgz..."
    create_initrd_stupid_simple "$NEST_ROOT"/rootfs.cgz

    msg "creating wrapper cgz..."
    ( cd "$NEST_ROOT" && find * | fakeroot cpio --create -H newc | gzip ) > "$1"
}

# tweak initrd method: untested, probably doesn't work right yet.  soon!
create_initrd_tweak_initrd() {
    cat "$DEBIRF_ROOT/scripts/debirf" <<EOF
mountroot() {
 rootmnt="/"
}
EOF
    cat > "$DEBIRF_ROOT/bin/run-init" <<EOF
#!/bin/sh
if [ "$1" != "/" ] ; then
  exec /usr/lib/klibc/bin/run-init "$@"
else
  MOUNT_POINT="$1"
  INIT="$2"
  shift 2
  exec "$INIT" "$@"
fi
EOF
    # create root image
    cp initrd.img* "$1"
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) >> "$1"
}

# unionfs method: also untested and probably not working.
create_initrd_unionfs() {
    #ln sbin/init to /init
    ln -sf /sbin/init "$DEBIRF_ROOT/init"
    
    # add unionfs kernel module and init script
    debirf_exec apt-get update
    debirf_exec apt-get install unionfs-modules-"$KERNAVAIL" unionfs-tools

    cat >"$DEBIRF_ROOT/etc/init.d/root-unionfs" <<EOF
#!/bin/bash

mount -t tmpfs tmpfs /tmp
mount -t unionfs dirs=/=ro:/tmp=rw unionfs /
EOF

    ln -sf ../init.d/root-unionfs /etc/rcS.d/S00root-unionfs

    # create root image
    ( cd "$DEBIRF_ROOT" && find * | cpio -H newc --create  | gzip ) > "$1"
}

###############################################################
### MAIN

# option parsing
TEMP=$(getopt --options -hfcnosik: --longoptions help,fakechroot,check-vars,new,overwrite,skip,initrd-only,kernel-deb: -n "$CMD" -- "$@")

if [ $? != 0 ] ; then
    echo "Invalid options." >&2 
    usage
    exit 1
fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

while true ; do
    case "$1" in
        -h|--help)
	    usage
	    exit 0
            ;;
        -f|--fakechroot)
	    FAKECHROOT_BUILD=true
            shift 1
            ;;
        -c|--check-vars)
            CHECK_VARS=true
            shift 1
            ;;
        -n|--new)
            WRITE_MODE=rewrite
            shift 1
            ;;
        -o|--overwrite)
            WRITE_MODE=overwrite
            shift 1
            ;;
        -s|--skip)
            WRITE_MODE=skip
            shift 1
            ;;
	-i|--initrd-only)
	    STAGE_ROOT=false
	    STAGE_PLUGINS=false
	    shift 1
	    ;;
	-k|--kernel-deb)
	    DEBIRF_KERNEL_PACKAGE="$2"
	    shift 2
	    ;;
        --)
            shift
            ;;
        *)
	    if (( $# < 1 )) ; then
		echo "Improper number of input arguments."
		usage
		exit 1
            fi
	    DEBIRF_PROFILE="$1"
            break
            ;;
    esac
done

if [ "$FAKECHROOT_BUILD" = 'true' ] ; then
    echo "Using fakechroot build."
fi	    
if [ "$DEBIRF_KERNEL_PACKAGE" ] ; then
    if [ -f "$DEBIRF_KERNEL_PACKAGE" ] ; then
	echo "Using kernel package '$DEBIRF_KERNEL_PACKAGE'."
    else
	failure "Kernel package '$DEBIRF_KERNEL_PACKAGE' not found."
    fi
fi

# source debirf.conf defaults
source /usr/share/debirf/debirf.conf.defaults

# check profile
if [ -d "$DEBIRF_PROFILE" ] ; then
    echo "Loading profile '$DEBIRF_PROFILE'..."
    DEBIRF_CONF="$DEBIRF_PROFILE/debirf.conf"
    DEBIRF_PLUGINS="$DEBIRF_PROFILE/plugins"
else
    echo "$DEBIRF_PROFILE not found."
    usage_profile
    exit 1
fi

# source profile debirf.conf
if [ -f "$DEBIRF_CONF" ] ; then
    source "$DEBIRF_CONF"
else
    echo "$DEBIRF_CONF not found."
    usage_profile
    exit 1
fi

# check plugins directory
if [ ! -d "$DEBIRF_PLUGINS" ] ; then
    echo "$DEBIRF_PLUGINS does not exist."
    usage_profile
    exit 1
fi
if [ $(ls "$DEBIRF_PLUGINS" -1 | wc -l) = 0 ] ; then
    echo "$DEBIRF_PLUGINS is empty."
    usage_profile
    exit 1
fi

# check buildd
if [ -z "$DEBIRF_BUILDD" ] ; then
    failure "DEBIRF_BUILDD is not set."
fi

# check debirf root
if [ -z "$DEBIRF_ROOT" ] ; then
    failure "DEBIRF_ROOT is not set."
fi

# set fakechroot save file
DEBIRF_FAKEROOT_STATE="$DEBIRF_BUILDD/.fakechroot-$DEBIRF_LABEL.save"

# check variables
if [ "$CHECK_VARS" ] ; then
    echo "Debirf variables:"
    for var in ${!DEBIRF_*}; do
	if [ $var ] ; then
	    export $var
	else
	    failure "Variable '$var' not properly set."
	fi
    done
    env | /bin/grep "^DEBIRF_"
    read -p "enter to continue: " OK
fi

### BUILD ROOT
if [ "$STAGE_ROOT" = 'true' ] ; then

# determine write mode
if [ -d "$DEBIRF_ROOT" ] ; then
    echo "Directory $DEBIRF_ROOT already exists."
    if [ -z "$WRITE_MODE" ] ; then
	echo "Select one of the following:"
	select foo in 'new' 'overwrite' 'skip' 'exit' ; do
	    case "$foo" in
		'new')
		    WRITE_MODE=rewrite
		    ;;
		'overwrite')
		    WRITE_MODE=overwrite
		    ;;
		'skip')
		    WRITE_MODE=skip
		    ;;
		*)
		    failure "aborting."
		    ;;
	    esac
	    break
	done
    fi
else
    WRITE_MODE=new
fi
case "$WRITE_MODE" in
    'new')
	msg "creating debirf root..."
	create_debootstrap
	;;
    'rewrite')
	msg "clearing old debirf root..."
	rm -rf "$DEBIRF_ROOT"
	msg "creating debirf root..."
	create_debootstrap
	;;
    'overwrite')
	msg "overwriting old debirf root..."
	create_debootstrap
	;;
    'skip')
	msg "skipping debootstrap..."
	;;
    *)
	failure "aborting."
	;;
esac
else
    echo "Not building root."
fi
### END BUILD ROOT


### RUN PLUGINS
if [ "$STAGE_PLUGINS" = 'true' ] ; then
    setup_debirf_info
    msg "executing plugins..."
    run_plugins
    msg "plugins complete."
else
    echo "Not running plugins."
fi
### END RUN PLUGINS


### BUILD INITRD
if [ "$STAGE_INITRD" = 'true' ] ; then
    if [ ! -d "$DEBIRF_ROOT" ] ; then
	failure "Root not found."
    fi
    # determine initrd name
    KERNEL_VERS=$(ls -1 "$DEBIRF_ROOT/lib/modules" | head -n1)
    DEBIRF_INITRD="${DEBIRF_LABEL}_${DEBIRF_DISTRO}_${KERNEL_VERS}.cgz"

    msg "creating debirf initrd ('$DEBIRF_METHOD')..."
    create_initrd_${DEBIRF_METHOD} "$DEBIRF_BUILDD/$DEBIRF_INITRD"

    # final output
    DEBIRF_KERNEL=$(ls "$DEBIRF_BUILDD" | grep "vmlinu" | grep "$KERNEL_VERS$")
    msg "debirf initrd created."
    if [ "$DEBIRF_BUILDD/$DEBIRF_KERNEL" ] ; then
	msg "kernel: $DEBIRF_BUILDD/$DEBIRF_KERNEL"
    fi
    msg "initrd: $DEBIRF_BUILDD/$DEBIRF_INITRD"
else
    echo "Not creating initramfs."
fi
### END BUILD INITRD
